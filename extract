<?php
/**
* KT Cigar Ultra-Intelligent Extraction System v9.0 - COMPLETE ENHANCED VERSION
* 🧠 Enhanced numerical pattern recognition and strict keyword extraction
* 🎯 Comprehensive number extraction: series, years, anniversaries, models
* 🚀 Eliminates description pollution and cross-brand contamination
* 
* MAJOR ENHANCEMENTS:
* - Advanced numerical pattern recognition (series, years, anniversaries)
* - Strict Chinese text extraction (no description pollution)
* - Enhanced anniversary and year detection
* - Comprehensive model and series number extraction
* - Eliminated supplier description processing
*/

if (!defined("ABSPATH")) {
   exit;
}

class KT_Cigar_Mappings {
   
   private static $data_file_path;
   private static $data_loaded = false;
   private static $cigar_data = array();
   private static $cuban_brands = array();
   private static $non_cuban_brands = array();
   private static $vitola_mappings = array();
   private static $series_brands = array();
   private static $special_editions = array();
   private static $regional_editions = array();
   private static $packaging_types = array();
   private static $wrapper_types = array();
   
   // 🎯 MAIN ENTRY POINT - ENHANCED DUAL EXTRACTION VERSION
   public static function process_supplier_product($title, $brand = '', $description = '') {
       if (!self::$data_loaded) {
           self::init();
       }
       
       $result = self::initialize_result($title);
       
       if (empty($title)) {
           return $result;
       }
       
       $clean_title = trim($title);
       self::write_mapping_log("🎯 PROCESSING: '$clean_title'");
       
       // PHASE 1: Enhanced Basic Pattern Recognition
       $basic_extractions = self::extract_basic_patterns_enhanced($clean_title);
       
       // PHASE 2: DUAL Datafile Extraction (English + Chinese keywords) 
       $datafile_extractions = self::extract_from_datafile_dual($clean_title, $brand);

       // PHASE 2.5: Anniversary Pattern Extraction
       $anniversary_extractions = self::extract_anniversary_patterns($clean_title);

       // PHASE 3: CRITICAL FIXES - Enhanced Packaging Detection
       $packaging_extractions = self::extract_packaging_enhanced($clean_title);

       // PHASE 4: Enhanced Intelligent Pattern Recognition with Numbers
       $pattern_extractions = self::extract_intelligent_patterns_enhanced($clean_title, array_merge($basic_extractions, $datafile_extractions, $anniversary_extractions));
       
       // PHASE 5: Preserve ALL Meaningful Segments (STRICT - title only)
       $preserved_segments = self::preserve_all_meaningful_text($clean_title, array_merge($basic_extractions, $datafile_extractions, $pattern_extractions));
       
       // MERGE ALL EXTRACTIONS
       $final_result = self::merge_all_extractions_dual($result, array(
           $basic_extractions,
           $datafile_extractions, 
           $anniversary_extractions,
           $packaging_extractions,
           $pattern_extractions,
           $preserved_segments
       ));
       
       self::write_mapping_log("✅ PROCESSING COMPLETE: " . count($final_result["keywords"]) . " keywords extracted");
       
       // ENSURE N/A VALUES
       $final_result = self::ensure_na_values($final_result);

       return $final_result;
   }
   
   // 🔥 PHASE 1: Enhanced Basic Pattern Recognition
   private static function extract_basic_patterns_enhanced($title) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("🔥 Phase 1: Basic patterns");
       
       // 1. ULTRA-ROBUST DIMENSION EXTRACTION
       $dimensions = self::extract_dimensions_ultra_robust($title);
       if ($dimensions) {
           if ($dimensions['ring_gauge']) {
               $extractions['ring_gauge'] = $dimensions['ring_gauge'];
               $extractions['keywords'][] = "RING:" . $dimensions['ring_gauge'];
               $extractions['confidence']['dimensions'] = 0.98;
               self::write_mapping_log("✅ Ring Gauge: " . $dimensions['ring_gauge']);
           }
           if ($dimensions['length_mm']) {
               $extractions['length'] = $dimensions['length_mm'];
               $extractions['length_mm'] = $dimensions['length_mm'];
               $extractions['keywords'][] = "LENGTH:" . $dimensions['length_mm'] . "mm";
               $extractions['confidence']['dimensions'] = 0.98;
               self::write_mapping_log("✅ Length: " . $dimensions['length_mm'] . "mm");
           }
       }
       
       // 2. ULTRA-ROBUST COUNT EXTRACTION
       $count_data = self::extract_count_ultra_robust($title);
       if ($count_data) {
           $extractions['count'] = $count_data['count'];
           $extractions['packaging'] = $count_data['packaging'];
           $extractions['keywords'][] = "COUNT:" . $count_data['count'];
           $extractions['keywords'][] = "PACK:" . $count_data['packaging'];
           $extractions['confidence']['count'] = 0.95;
           self::write_mapping_log("✅ Count: " . $count_data['count'] . " " . $count_data['packaging']);
       }
       
       // 3. ENHANCED YEAR EXTRACTION
       $year_data = self::extract_year_robust($title);
       if ($year_data) {
           $extractions['year'] = $year_data['year'];
           $extractions['keywords'][] = "YEAR:" . $year_data['year'];
           $extractions['confidence']['year'] = $year_data['confidence'];
           self::write_mapping_log("✅ Year: " . $year_data['year']);
       }
       
       return $extractions;
   }
   
   // 🚀 PHASE 2: DUAL Datafile Extraction (English + Chinese)
   private static function extract_from_datafile_dual($title, $provided_brand) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("🚀 Phase 2: Dual datafile extraction");
       
       $title_lower = mb_strtolower($title, 'UTF-8');
       
       // 1. ENHANCED BRAND EXTRACTION WITH DATAFILE NORMALIZATION
       $brand_result = self::extract_brand_comprehensive($title, $provided_brand);
       if ($brand_result) {
           $extractions['brand'] = $brand_result['brand'];
           $extractions['keywords'][] = "BRAND:" . $brand_result['brand'];
           $extractions['confidence']['brand'] = $brand_result['confidence'];
           
           // Preserve original brand if different
           if (isset($brand_result['original_brand']) && $brand_result['original_brand'] !== $brand_result['brand']) {
               $extractions['keywords'][] = "ORIGINAL_BRAND:" . $brand_result['original_brand'];
           }
           
           // Add brand type info
           if (isset($brand_result['brand_type'])) {
               $extractions['keywords'][] = "BRAND_TYPE:" . $brand_result['brand_type'];
           }
           
           self::write_mapping_log("✅ Enhanced Brand: " . $brand_result['brand'] . " (type: " . ($brand_result['brand_type'] ?? 'unknown') . ")");
       }
       
       // 2. DUAL VITOLA SCANNING - EXTRACTS BOTH ENGLISH AND CHINESE
       $vitola_result = self::scan_vitolas_dual($title_lower);
       if ($vitola_result) {
           $extractions['vitola'] = $vitola_result['vitola'];
           $extractions['keywords'][] = "VITOLA:" . $vitola_result['vitola'];
           $extractions['keywords'][] = "CHINESE:" . $vitola_result['matched_term'];
           $extractions['confidence']['vitola'] = $vitola_result['confidence'];
           self::write_mapping_log("✅ Vitola: " . $vitola_result['vitola'] . " (Chinese: " . $vitola_result['matched_term'] . ")");
       }
       
       // 3. DUAL SERIES SCANNING - EXTRACTS BOTH ENGLISH AND CHINESE
       $series_results = self::scan_series_dual($title_lower, $extractions['brand'] ?? '');
       if (!empty($series_results)) {
           $series_result = $series_results[0]; // Take best match
           $extractions['series'] = $series_result['series'];
           $extractions['keywords'][] = "SERIES:" . $series_result['series'];
           $extractions['keywords'][] = "CHINESE:" . $series_result['matched_term'];
           $extractions['confidence']['series'] = $series_result['confidence'];
           self::write_mapping_log("✅ Series: " . $series_result['series'] . " (Chinese: " . $series_result['matched_term'] . ")");
       }
       
       // 4. SPECIAL EDITIONS
       $special_results = self::scan_special_editions_conservative($title_lower);
       if (!empty($special_results)) {
           $special_result = $special_results[0];
           $extractions['special_edition'] = $special_result['type'];
           $extractions['keywords'][] = "SPECIAL:" . $special_result['type'];
           $extractions['confidence']['special'] = $special_result['confidence'];
           self::write_mapping_log("✅ Special: " . $special_result['type']);
       }
       
       // 5. WRAPPER TYPES
       $wrapper_result = self::scan_wrapper_types($title_lower);
       if ($wrapper_result) {
           $extractions['wrapper_type'] = $wrapper_result['wrapper'];
           $extractions['keywords'][] = "WRAPPER:" . $wrapper_result['wrapper'];
           $extractions['confidence']['wrapper'] = $wrapper_result['confidence'];
           self::write_mapping_log("✅ Wrapper: " . $wrapper_result['wrapper']);
       }
       
       return $extractions;
   }

   // 🎊 PHASE 2.5: ENHANCED Anniversary Pattern Extraction
   private static function extract_anniversary_patterns($title) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("🎊 Phase 2.5: Anniversary patterns");
       
       $anniversary_patterns = array(
           // Chinese anniversary: 25周年, 50周年纪念, 10周年限量
           '/(\d{1,3})周年(?:纪念|限量|版|特制)?/u' => 0.95,
           
           // English anniversary: 25th Anniversary, 50th Anniversary Limited
           '/(\d{1,3})(?:st|nd|rd|th)\s*anniversary(?:\s*(?:limited|edition|special))?/iu' => 0.95,
           
           // Anniversary of founding: 成立25周年, Founded 50 years
           '/(?:成立|founded)\s*(\d{1,3})(?:周年|years?)/iu' => 0.90,
           
           // Celebration patterns: 庆祝25周年, Celebrating 50 years
           '/(?:庆祝|celebrating)\s*(\d{1,3})(?:周年|years?)/iu' => 0.90
       );
       
       foreach ($anniversary_patterns as $pattern => $confidence) {
           if (preg_match($pattern, $title, $matches)) {
               $anniversary_years = intval($matches[1]);
               
               if ($anniversary_years >= 1 && $anniversary_years <= 200) {
                   $extractions['anniversary_years'] = $anniversary_years;
                   $extractions['special_edition'] = $anniversary_years . ' anniversary';
                   $extractions['keywords'][] = "ANNIVERSARY:" . $anniversary_years;
                   $extractions['keywords'][] = "SPECIAL:" . $anniversary_years . " anniversary";
                   $extractions['confidence']['anniversary'] = $confidence;
                   
                   self::write_mapping_log("✅ Anniversary extracted: " . $anniversary_years . " years");
                   break; // Take first match
               }
           }
       }
       
       return $extractions;
   }
   
   // 🔍 DUAL VITOLA SCANNING - EXTRACTS BOTH ENGLISH AND CHINESE - USES DATAFILE
   private static function scan_vitolas_dual($title_lower) {
       if (empty(self::$vitola_mappings)) {
           self::write_mapping_log("❌ No vitola mappings loaded from datafile");
           return null;
       }
       
       self::write_mapping_log("🔍 Scanning vitolas in: '" . mb_substr($title_lower, 0, 50) . "'");
       self::write_mapping_log("🔍 Available vitola mappings from datafile: " . count(self::$vitola_mappings));
       
       $best_match = null;
       $highest_confidence = 0;
       $longest_match_length = 0;
       
       // Use complete vitola_mappings from datafile
       foreach (self::$vitola_mappings as $english_vitola => $chinese_alternatives) {
           // Check English vitola name first
           $english_lower = mb_strtolower($english_vitola, 'UTF-8');
           if (mb_strpos($title_lower, $english_lower) !== false) {
               $match_length = mb_strlen($english_vitola, 'UTF-8');
               $confidence = 0.90 + ($match_length * 0.01);
               
               if ($confidence > $highest_confidence || 
                   ($confidence == $highest_confidence && $match_length > $longest_match_length)) {
                   $best_match = array(
                       'vitola' => $english_vitola,
                       'confidence' => $confidence,
                       'matched_term' => $english_vitola
                   );
                   $highest_confidence = $confidence;
                   $longest_match_length = $match_length;
                   self::write_mapping_log("🎯 Found English vitola match from datafile: $english_vitola");
               }
           }
           
           // Check Chinese alternatives from datafile
           if (is_array($chinese_alternatives)) {
               foreach ($chinese_alternatives as $chinese_term) {
                   $chinese_lower = mb_strtolower($chinese_term, 'UTF-8');
                   if (mb_strpos($title_lower, $chinese_lower) !== false) {
                       $match_length = mb_strlen($chinese_term, 'UTF-8');
                       $confidence = 0.88 + ($match_length * 0.02);
                       
                       if ($confidence > $highest_confidence || 
                           ($confidence == $highest_confidence && $match_length > $longest_match_length)) {
                           $best_match = array(
                               'vitola' => $english_vitola,
                               'confidence' => $confidence,
                               'matched_term' => $chinese_term
                           );
                           $highest_confidence = $confidence;
                           $longest_match_length = $match_length;
                           self::write_mapping_log("🎯 Found Chinese vitola match from datafile: '$chinese_term' → $english_vitola");
                       }
                   }
               }
           }
       }
       
       if ($best_match) {
           self::write_mapping_log("✅ VITOLA MATCH FOUND: " . $best_match['vitola'] . " (confidence: " . $best_match['confidence'] . ")");
       } else {
           self::write_mapping_log("❌ No vitola matches found in datafile");
       }
       
       return $best_match;
   }
   
   // 📊 DUAL SERIES SCANNING - EXTRACTS BOTH ENGLISH AND CHINESE - USES DATAFILE
   private static function scan_series_dual($title_lower, $brand) {
       $results = array();
       
       self::write_mapping_log("📊 Scanning series in: '" . mb_substr($title_lower, 0, 50) . "'");
       
       // FIRST: Check special_editions from datafile for series terms
       if (!empty(self::$special_editions)) {
           foreach (self::$special_editions as $english_series => $chinese_variants) {
               if (is_array($chinese_variants)) {
                   foreach ($chinese_variants as $chinese_term) {
                       $chinese_lower = mb_strtolower($chinese_term, 'UTF-8');
                       if (mb_strpos($title_lower, $chinese_lower) !== false) {
                           $results[] = array(
                               'series' => $english_series,
                               'confidence' => 0.90,
                               'matched_term' => $chinese_term
                           );
                           self::write_mapping_log("🎯 Found special edition series from datafile: '$chinese_term' → $english_series");
                           return $results;
                       }
                   }
               }
               
               // Also check English series names
               $english_lower = mb_strtolower($english_series, 'UTF-8');
               if (mb_strpos($title_lower, $english_lower) !== false) {
                   $results[] = array(
                       'series' => $english_series,
                       'confidence' => 0.88,
                       'matched_term' => $english_series
                   );
                   self::write_mapping_log("🎯 Found special edition series (English) from datafile: $english_series");
                   return $results;
               }
           }
       }
       
       // SECOND: Check if we have series data for this specific brand
       if (!empty($brand) && !empty(self::$series_brands)) {
           $brand_lower = mb_strtolower($brand, 'UTF-8');
           
           foreach (self::$series_brands as $brand_key => $series_data) {
               $brand_key_lower = mb_strtolower($brand_key, 'UTF-8');
               
               // Check if this brand matches
               if (mb_strpos($brand_key_lower, $brand_lower) !== false || 
                   mb_strpos($brand_lower, $brand_key_lower) !== false) {
                   
                   if (is_array($series_data)) {
                       foreach ($series_data as $series_name => $series_alternatives) {
                           // Check series name
                           $series_lower = mb_strtolower($series_name, 'UTF-8');
                           if (mb_strpos($title_lower, $series_lower) !== false) {
                               $results[] = array(
                                   'series' => $series_name,
                                   'confidence' => 0.92,
                                   'matched_term' => $series_name
                               );
                               self::write_mapping_log("🎯 Found brand-specific series from datafile: $series_name");
                               return $results;
                           }
                           
                           // Check alternatives from datafile
                           if (is_array($series_alternatives)) {
                               foreach ($series_alternatives as $alternative) {
                                   $alt_lower = mb_strtolower($alternative, 'UTF-8');
                                   if (mb_strpos($title_lower, $alt_lower) !== false) {
                                       $results[] = array(
                                           'series' => $series_name,
                                           'confidence' => 0.90,
                                           'matched_term' => $alternative
                                       );
                                       self::write_mapping_log("🎯 Found brand-specific series via alternative from datafile: '$alternative' → $series_name");
                                       return $results;
                                   }
                               }
                           }
                       }
                   }
               }
           }
       }
       
       // THIRD: Generic series scanning using datafile
       if (!empty(self::$series_brands)) {
           foreach (self::$series_brands as $brand_key => $series_data) {
               if (is_array($series_data)) {
                   foreach ($series_data as $series_name => $series_alternatives) {
                       // Check series name
                       $series_lower = mb_strtolower($series_name, 'UTF-8');
                       if (mb_strpos($title_lower, $series_lower) !== false) {
                           $results[] = array(
                               'series' => $series_name,
                               'confidence' => 0.75,
                               'matched_term' => $series_name
                           );
                           self::write_mapping_log("🎯 Found generic series from datafile: $series_name");
                           return $results;
                       }
                       
                       // Check alternatives from datafile
                       if (is_array($series_alternatives)) {
                           foreach ($series_alternatives as $alternative) {
                               $alt_lower = mb_strtolower($alternative, 'UTF-8');
                               if (mb_strpos($title_lower, $alt_lower) !== false) {
                                   $results[] = array(
                                       'series' => $series_name,
                                       'confidence' => 0.70,
                                       'matched_term' => $alternative
                                   );
                                   self::write_mapping_log("🎯 Found generic series via alternative from datafile: '$alternative' → $series_name");
                                   return $results;
                               }
                           }
                       }
                   }
               }
           }
       }
       
       // FOURTH: Pattern-based series detection for codes not in datafile
       // NUMERIC SERIES with # symbols: #1, #2, #3, etc.
       if (preg_match('/#\s*(\d+)/u', $title_lower, $matches)) {
           $series_num = $matches[1];
           $results[] = array(
               'series' => "#" . $series_num,
               'confidence' => 0.85,
               'matched_term' => $matches[0]
           );
           self::write_mapping_log("🎯 Found # series pattern: #" . $series_num);
           return $results;
       }
       
       // NO. patterns: No.1, No.2, No 3, NO.4, etc.
       if (preg_match('/\b(?:no|NO)\.?\s*(\d+)\b/u', $title_lower, $matches)) {
           $series_num = $matches[1];
           $results[] = array(
               'series' => "No." . $series_num,
               'confidence' => 0.82,
               'matched_term' => $matches[0]
           );
           self::write_mapping_log("🎯 Found No. series pattern: No." . $series_num);
           return $results;
       }
       
       // ALPHANUMERIC SERIES: T52, VF52, L40, UF13, etc.
       if (preg_match('/\b([A-Z]{1,3}\d{1,4})\b/u', $title_lower, $matches)) {
           $series_code = $matches[1];
           $results[] = array(
               'series' => $series_code,
               'confidence' => 0.80,
               'matched_term' => $series_code
           );
           self::write_mapping_log("🎯 Found alphanumeric series pattern: " . $series_code);
           return $results;
       }
       
       self::write_mapping_log("❌ No series matches found");
       return $results;
   }
   
   // 🧠 PHASE 4: Enhanced Intelligent Pattern Recognition with Comprehensive Number Extraction
   private static function extract_intelligent_patterns_enhanced($title, $already_extracted) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("🧠 Phase 4: Enhanced intelligent patterns with comprehensive number extraction");
       
       // Remove already extracted terms
       $remaining_text = $title;
       foreach ($already_extracted as $extraction) {
           if (isset($extraction['brand']) && $extraction['brand']) {
               $remaining_text = str_ireplace($extraction['brand'], ' ', $remaining_text);
           }
       }
       
       // COMPREHENSIVE NUMERICAL PATTERN EXTRACTION
       $numeric_patterns = array(
           // Hash patterns: #1, #2, #25, etc.
           '/#\s*(\d+)/u' => array('type' => 'hash_series', 'prefix' => '#'),
           
           // No patterns: No.1, No.2, No 25, NO.4, etc.
           '/\b(?:no|NO)\.?\s*(\d{1,3})\b/u' => array('type' => 'no_series', 'prefix' => 'No.'),
           
           // Chinese number patterns: 1号, 2号, 25号
           '/(\d{1,3})号/u' => array('type' => 'chinese_number', 'prefix' => ''),
           
           // Anniversary years: 25周年, 50周年, 25th Anniversary, 50th Anniversary  
           '/(\d{1,3})(?:周年|th\s*anniversary|st\s*anniversary|nd\s*anniversary|rd\s*anniversary)/iu' => array('type' => 'anniversary', 'prefix' => ''),
           
           // Release years: 1998年, 2023年, 1964版, 2024版
           '/\b(19\d{2}|20[0-2]\d)(?:年|版)\b/u' => array('type' => 'year', 'prefix' => ''),
           
           // English years: Year 1998, 2023 Edition, Vintage 1964
           '/\b(?:year|vintage|edition)?\s*(19\d{2}|20[0-2]\d)\s*(?:edition|vintage|year)?\b/iu' => array('type' => 'year', 'prefix' => ''),
           
           // Series codes: T52, VF52, LAT52, UF13, L40
           '/\b([A-Z]{1,4}\d{1,4})\b/u' => array('type' => 'alpha_series', 'prefix' => ''),
           
           // Model numbers: 1518, 1926, 1964 (standalone numbers that aren't dimensions)
           '/\b(\d{3,4})\b/u' => array('type' => 'model_number', 'prefix' => ''),
           
           // Generation numbers: 第一代, 第二代, 1st Generation, 2nd Generation
           '/(?:第([一二三四五六七八九十\d]+)代|(\d+)(?:st|nd|rd|th)\s*generation)/iu' => array('type' => 'generation', 'prefix' => ''),
           
           // Limited quantities: 限量3000, Limited 5000, 限定1000
           '/(?:限量|限定|limited)\s*(\d{1,6})/iu' => array('type' => 'limited_quantity', 'prefix' => ''),
           
           // Special numbers in parentheses: (2025), (1998), (25)
           '/\((\d{1,4})\)/u' => array('type' => 'special_number', 'prefix' => ''),
           
           // Decimal series: 5.5, 6.2, 7.5 (common for cigar series)
           '/\b(\d{1,2}\.\d{1,2})\b/u' => array('type' => 'decimal_series', 'prefix' => '')
       );

       foreach ($numeric_patterns as $pattern => $config) {
           if (preg_match($pattern, $remaining_text, $matches)) {
               $number = $matches[1];
               $type = $config['type'];
               
               // Validate the number based on type
               if ($type === 'year' && ($number < 1900 || $number > 2030)) {
                   continue; // Skip invalid years
               }
               
               if ($type === 'model_number') {
                   // Skip if it looks like dimensions (ring gauge 20-80, length 80-300)
                   $num = intval($number);
                   if (($num >= 20 && $num <= 80) || ($num >= 80 && $num <= 300)) {
                       continue;
                   }
               }
               
               // Extract based on type
               switch ($type) {
                   case 'hash_series':
                   case 'no_series':
                   case 'alpha_series':
                       $series_value = $config['prefix'] . $number;
                       $extractions['series'] = $series_value;
                       $extractions['model'] = $series_value;
                       $extractions['keywords'][] = "SERIES:" . $series_value;
                       $extractions['keywords'][] = "MODEL:" . $series_value;
                       $extractions['confidence']['series'] = 0.95;
                       self::write_mapping_log("✅ Series/Model extracted: " . $series_value);
                       break;
                       
                   case 'chinese_number':
                       $extractions['model'] = $number . '号';
                       $extractions['keywords'][] = "MODEL:" . $number;
                       $extractions['keywords'][] = "CHINESE:" . $number . '号';
                       $extractions['confidence']['model'] = 0.90;
                       self::write_mapping_log("✅ Chinese number extracted: " . $number . '号');
                       break;
                       
                   case 'anniversary':
                       $extractions['special_edition'] = $number . ' anniversary';
                       $extractions['year'] = date('Y'); // Current year for anniversary
                       $extractions['keywords'][] = "SPECIAL:" . $number . " anniversary";
                       $extractions['keywords'][] = "ANNIVERSARY:" . $number;
                       $extractions['confidence']['special'] = 0.95;
                       self::write_mapping_log("✅ Anniversary extracted: " . $number . ' anniversary');
                       break;
                       
                   case 'year':
                       $extractions['year'] = $number;
                       $extractions['keywords'][] = "YEAR:" . $number;
                       $extractions['confidence']['year'] = 0.95;
                       self::write_mapping_log("✅ Year extracted: " . $number);
                       break;
                       
                   case 'generation':
                       $gen_num = is_numeric($number) ? $number : self::chinese_number_to_arabic($number);
                       $extractions['generation'] = $gen_num . ' generation';
                       $extractions['keywords'][] = "GENERATION:" . $gen_num;
                       $extractions['confidence']['generation'] = 0.85;
                       self::write_mapping_log("✅ Generation extracted: " . $gen_num . ' generation');
                       break;
                       
                   case 'limited_quantity':
                       $extractions['limited_quantity'] = $number;
                       $extractions['special_edition'] = 'limited ' . $number;
                       $extractions['keywords'][] = "LIMITED:" . $number;
                       $extractions['keywords'][] = "QUANTITY:" . $number;
                       $extractions['confidence']['special'] = 0.90;
                       self::write_mapping_log("✅ Limited quantity extracted: " . $number);
                       break;
                       
                   case 'special_number':
                       // Could be year, series, or model - be smart about it
                       if ($number >= 1900 && $number <= 2030) {
                           $extractions['year'] = $number;
                           $extractions['keywords'][] = "YEAR:" . $number;
                       } elseif ($number >= 1 && $number <= 99) {
                           $extractions['model'] = $number;
                           $extractions['keywords'][] = "MODEL:" . $number;
                       } else {
                           $extractions['special_number'] = $number;
                           $extractions['keywords'][] = "NUMBER:" . $number;
                       }
                       self::write_mapping_log("✅ Special number extracted: " . $number);
                       break;
                       
                   case 'decimal_series':
                       $extractions['series'] = $number;
                       $extractions['keywords'][] = "SERIES:" . $number;
                       $extractions['confidence']['series'] = 0.85;
                       self::write_mapping_log("✅ Decimal series extracted: " . $number);
                       break;
                       
                   case 'model_number':
                       $extractions['model'] = $number;
                       $extractions['keywords'][] = "MODEL:" . $number;
                       $extractions['confidence']['model'] = 0.80;
                       self::write_mapping_log("✅ Model number extracted: " . $number);
                       break;
               }
               
               // Only process first match to avoid conflicts
               break;
           }
       }
       
       // 5. CHINESE SERIES NAMES: 音乐 (music), 精选 (selection), 丰收 (harvest)
       $chinese_series_patterns = array(
           '音乐' => 'music',
           '精选' => 'selection', 
           '丰收' => 'harvest',
           '珍藏' => 'reserve',
           '特级' => 'premium',
           '经典' => 'classic',
           '限量' => 'limited',
           '收藏' => 'collection',
           '纪念' => 'anniversary'
       );
       
       foreach ($chinese_series_patterns as $chinese => $english) {
           if (mb_strpos($remaining_text, $chinese) !== false) {
               $extractions['series'] = $english;
               $extractions['keywords'][] = "SERIES:" . $english;
               $extractions['keywords'][] = "CHINESE:" . $chinese;
               $extractions['confidence']['series'] = 0.88;
               self::write_mapping_log("✅ Chinese series: '$chinese' → $english");
           }
       }
       
       // 6. COLLECTION/SAMPLER patterns
       if (preg_match('/(?:collection|sampler|selection|assortment)/i', $remaining_text, $matches)) {
           $collection_type = strtolower($matches[0]);
           $extractions['special_edition'] = $collection_type;
           $extractions['keywords'][] = "SPECIAL:" . $collection_type;
           $extractions['confidence']['special'] = 0.85;
           self::write_mapping_log("✅ Collection type: " . $collection_type);
       }
       
       return $extractions;
   }

   /**
    * Convert Chinese numbers to Arabic numerals
    */
   private static function chinese_number_to_arabic($chinese) {
       $map = array(
           '一' => 1, '二' => 2, '三' => 3, '四' => 4, '五' => 5,
           '六' => 6, '七' => 7, '八' => 8, '九' => 9, '十' => 10,
           '零' => 0
       );
       
       if (isset($map[$chinese])) {
           return $map[$chinese];
       }
       
       return $chinese; // Return as-is if not found
   }
   
   // 💎 PHASE 5: Preserve ALL Meaningful Text (STRICT - title only, no description pollution)
   private static function preserve_all_meaningful_text($title, $already_extracted) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("💎 Phase 5: Preserving essential Chinese text from TITLE ONLY (no description pollution)");
       
       // CRITICAL FIX: Only extract from TITLE, stop at first parenthesis to avoid descriptions
       $title_only = preg_split('/[（(]/', $title)[0];
       $title_only = trim($title_only);
       
       self::write_mapping_log("🔍 Text for preservation (title only): '" . mb_substr($title_only, 0, 50) . "'");
       
       // BUILD essential terms list from DATAFILE instead of hardcoding
       $essential_chinese_terms = array();
       
       // Extract Chinese terms from vitola mappings datafile
       if (!empty(self::$vitola_mappings)) {
           foreach (self::$vitola_mappings as $english_vitola => $chinese_variants) {
               if (is_array($chinese_variants)) {
                   $essential_chinese_terms = array_merge($essential_chinese_terms, $chinese_variants);
               }
           }
       }
       
       // Extract Chinese terms from special_editions datafile
       if (!empty(self::$special_editions)) {
           foreach (self::$special_editions as $english_special => $chinese_variants) {
               if (is_array($chinese_variants)) {
                   $essential_chinese_terms = array_merge($essential_chinese_terms, $chinese_variants);
               }
           }
       }
       
       // Extract Chinese terms from brand mappings datafile
       if (!empty(self::$cuban_brands)) {
           foreach (self::$cuban_brands as $brand_key => $brand_data) {
               if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
                   foreach ($brand_data['alternatives'] as $alt) {
                       if (preg_match('/[\x{4e00}-\x{9fff}]/u', $alt)) {
                           $essential_chinese_terms[] = $alt;
                       }
                   }
               }
           }
       }
       
       if (!empty(self::$non_cuban_brands)) {
           foreach (self::$non_cuban_brands as $brand_key => $brand_data) {
               if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
                   foreach ($brand_data['alternatives'] as $alt) {
                       if (preg_match('/[\x{4e00}-\x{9fff}]/u', $alt)) {
                           $essential_chinese_terms[] = $alt;
                       }
                   }
               }
           }
       }
       
       // Remove duplicates and empty values
       $essential_chinese_terms = array_unique(array_filter($essential_chinese_terms));
       
       self::write_mapping_log("📊 Built essential terms list from datafile: " . count($essential_chinese_terms) . " terms");
       
       // ENHANCED: Extract both meaningful Chinese AND numbers with Chinese context
       if (preg_match_all('/[\x{4e00}-\x{9fff}]*\d+[\x{4e00}-\x{9fff}]*|[\x{4e00}-\x{9fff}]{2,6}/u', $title_only, $matches)) {
           foreach ($matches[0] as $segment) {
               $is_essential = false;
               
               // Check if this segment contains any essential term from datafile
               foreach ($essential_chinese_terms as $term) {
                   if (mb_strpos($segment, $term) !== false || mb_strpos($term, $segment) !== false) {
                       $is_essential = true;
                       break;
                   }
               }
               
               // Also consider segments with numbers + Chinese characters as essential
               if (!$is_essential && preg_match('/\d+[\x{4e00}-\x{9fff}]+/', $segment)) {
                   $is_essential = true;
               }
               
               // Only preserve if essential AND not already captured
               if ($is_essential) {
                   $already_has_chinese = false;
                   foreach ($already_extracted as $extraction) {
                       if (isset($extraction['keywords']) && is_array($extraction['keywords'])) {
                           foreach ($extraction['keywords'] as $keyword) {
                               if ($keyword === "CHINESE:" . $segment) {
                                   $already_has_chinese = true;
                                   break 2;
                               }
                           }
                       }
                   }
                   
                   if (!$already_has_chinese) {
                       $extractions['keywords'][] = "CHINESE:" . $segment;
                       self::write_mapping_log("💎 Preserved essential Chinese from datafile: " . $segment);
                   }
               }
           }
       }
       
       self::write_mapping_log("💎 Preserved " . count($extractions['keywords']) . " essential Chinese terms from datafile");
       
       return $extractions;
   }
 
   // REPLACE extract_dimensions_ultra_robust with this enhanced version:
   private static function extract_dimensions_ultra_robust($title) {
       self::write_mapping_log("🔧 Enhanced dimension extraction from: " . mb_substr($title, 0, 100));
       self::write_mapping_log("🔧 Full title for dimension extraction: '$title'");
       
       $dimension_patterns = array(
           // ENHANCED BRACKET PATTERNS
           '/【(\d{2,3})×(\d{2,3})】/' => 'chinese_brackets',
           '/【(\d{2,3})\*(\d{2,3})】/' => 'chinese_brackets_asterisk',
           '/\[(\d{2,3})[×xX*](\d{2,3})\]/' => 'square_brackets',
           '/[\[\(（]\s*(\d{2,3})\s*[xX×*]\s*(\d{2,3})\s*[\]\)）]/' => 'mixed_brackets',
           '/（(\d{2,3})×(\d{2,3})）/' => 'chinese_parentheses',
           '/\((\d{2,3})[×xX*](\d{2,3})\)/' => 'parentheses',
           
           // SLASH PATTERNS - ENHANCED
           '/\((\d{2,3})\/(\d{1,3}(?:\.\d+)?)\)/' => 'parentheses_slash',
           '/(\d{2,3})\/(\d{1,3}(?:\.\d+)?)/' => 'direct_slash',
           
           // MULTIPLICATION PATTERNS
           '/(\d{2,3})\s*[xX×*]\s*(\d{2,3})/' => 'multiplication',
           '/(\d{2,3})\s*\*\s*(\d{2,3})/' => 'asterisk',
           
           // SMALL FORMAT PATTERNS
           '/\(\s*(\d{1,2})\s*[xX×*]\s*(\d{1,3})\s*\)/' => 'small_format',
           '/(\d{1,2}(?:\.\d+)?)\s*[xX×*]\s*(\d{2,3})/' => 'decimal_format',
           '/(\d{2,3})\s*[xX×*]\s*(\d{1,2}(?:\.\d+)?)/' => 'reverse_decimal',
       );
       
       foreach ($dimension_patterns as $pattern => $type) {
           if (preg_match($pattern, $title, $matches)) {
               $num1 = floatval($matches[1]);
               $num2 = floatval($matches[2]);
               
               self::write_mapping_log("🔍 Found dimension pattern ($type): " . $matches[0] . " -> $num1 x $num2");
               
               $ring_gauge = null;
               $length_mm = null;
               
               // ENHANCED SMART ASSIGNMENT LOGIC
               if ($num1 >= 20 && $num1 <= 80 && $num2 >= 80 && $num2 <= 250) {
                   // Ring x Length (mm)
                   $ring_gauge = intval($num1);
                   $length_mm = intval($num2);
               } elseif ($num2 >= 20 && $num2 <= 80 && $num1 >= 80 && $num1 <= 250) {
                   // Length (mm) x Ring
                   $ring_gauge = intval($num2);
                   $length_mm = intval($num1);
               } elseif ($num1 >= 20 && $num1 <= 80 && $num2 >= 3 && $num2 <= 12) {
                   // Ring x Length (inches)
                   $ring_gauge = intval($num1);
                   $length_mm = round($num2 * 25.4);
               } elseif ($num2 >= 20 && $num2 <= 80 && $num1 >= 3 && $num1 <= 12) {
                   // Length (inches) x Ring
                   $ring_gauge = intval($num2);
                   $length_mm = round($num1 * 25.4);
               } elseif ($num1 <= 15 && $num2 >= 20 && $num2 <= 80) {
                   // Small length (inches) x Ring
                   $ring_gauge = intval($num2);
                   $length_mm = round($num1 * 25.4);
               } elseif ($num2 <= 15 && $num1 >= 20 && $num1 <= 80) {
                   // Ring x Small length (inches)
                   $ring_gauge = intval($num1);
                   $length_mm = round($num2 * 25.4);
               }
               
               if ($ring_gauge || $length_mm) {
                   self::write_mapping_log("✅ Enhanced dimensions: Ring=" . ($ring_gauge ?: 'N/A') . ", Length=" . ($length_mm ?: 'N/A') . "mm");
                   return array(
                       'ring_gauge' => $ring_gauge,
                       'length_mm' => $length_mm,
                       'pattern' => $matches[0],
                       'pattern_type' => $type
                   );
               }
           }
       }
       
       return null;
   }
   
   // 🔧 ULTRA-ROBUST COUNT EXTRACTION
   private static function extract_count_ultra_robust($title) {
       self::write_mapping_log("🔧 Extracting count");
       
       $count_patterns = array(
           // Standard: (20支/盒), (10支/盒), （20支/盒）
           '/[\(（]\s*(\d+)\s*支\s*\/\s*([盒箱包])\s*[\)）]/',
           // Simple: (20支), （25支）
           '/[\(（]\s*(\d+)\s*支\s*[\)）]/',
           // Direct: 20支/盒, 25支/箱
           '/(\d+)\s*支\s*\/\s*([盒箱包])/',
           // 装 format: 20支装, 25支装
           '/(\d+)\s*支\s*装/',
           // English: (20 pieces), (25 pcs)
           '/[\(（]\s*(\d+)\s*(?:pieces?|pcs?)\s*[\)）]/i',
           // Multiple format: (2 X 15支/盒)
           '/[\(（]\s*\d+\s*[xX×]\s*(\d+)\s*支\s*\/\s*([盒箱包])\s*[\)）]/',
           // Chinese parentheses: （20支/盒）
           '/（(\d+)支\/([盒箱包])）/',
           // Bracketed: [20支/盒], 【25支/盒】
           '/[\[【]\s*(\d+)\s*支\s*\/\s*([盒箱包])\s*[\]】]/',
       );
       
       foreach ($count_patterns as $pattern) {
           if (preg_match($pattern, $title, $matches)) {
               $count = intval($matches[1]);
               $packaging_chinese = isset($matches[2]) ? $matches[2] : '支';
               
               if ($count >= 1 && $count <= 1000) {
                   $packaging_english = self::map_packaging_to_english($packaging_chinese);
                   
                   self::write_mapping_log("✅ Count extracted: $count $packaging_chinese -> $count $packaging_english");
                   return array(
                       'count' => $count,
                       'packaging' => $packaging_english,
                       'packaging_chinese' => $packaging_chinese,
                       'pattern' => $matches[0]
                   );
               }
           }
       }
       
       return null;
   }
 
   // 📦 ENHANCED PACKAGING EXTRACTION - USES DATAFILE
   private static function extract_packaging_enhanced($title) {
       $extractions = array(
           'keywords' => array(),
           'confidence' => array()
       );
       
       self::write_mapping_log("📦 Enhanced packaging extraction from datafile");
       
       $title_lower = mb_strtolower($title, 'UTF-8');
       
       // Use comprehensive packaging mappings from datafile
       if (!empty(self::$packaging_types)) {
           foreach (self::$packaging_types as $english_type => $variants) {
               if (is_array($variants)) {
                   foreach ($variants as $variant) {
                       $variant_lower = mb_strtolower($variant, 'UTF-8');
                       if (mb_strpos($title_lower, $variant_lower) !== false) {
                           $extractions['packaging'] = $english_type;
                           $extractions['keywords'][] = "PACKAGING:" . $english_type;
                           $extractions['confidence']['packaging'] = 0.92;
                           self::write_mapping_log("✅ Packaging from datafile: '$variant' → $english_type");
                           return $extractions;
                       }
                   }
               }
               
               // Also check English packaging type directly
               $english_lower = mb_strtolower($english_type, 'UTF-8');
               if (mb_strpos($title_lower, $english_lower) !== false) {
                   $extractions['packaging'] = $english_type;
                   $extractions['keywords'][] = "PACKAGING:" . $english_type;
                   $extractions['confidence']['packaging'] = 0.90;
                   self::write_mapping_log("✅ Packaging (English) from datafile: $english_type");
                   return $extractions;
               }
           }
       } else {
           self::write_mapping_log("❌ No packaging data loaded from datafile");
       }
       
       // Pattern-based packaging detection for items not in datafile
       $pattern_packages = array(
           // C/P PATTERNS - HIGHEST PRIORITY
           '/\bC\/P\b/i' => array('type' => 'cardboard pack', 'confidence' => 0.95),
           '/\bc\.p\.\b/i' => array('type' => 'cardboard pack', 'confidence' => 0.95),
           '/\bCP\b/' => array('type' => 'cardboard pack', 'confidence' => 0.90),
           
           // TUBE PATTERNS
           '/\btubed?\b/i' => array('type' => 'tube', 'confidence' => 0.85),
           '/管装/u' => array('type' => 'tube', 'confidence' => 0.85),
           
           // HUMIDOR PATTERNS
           '/保湿盒/u' => array('type' => 'humidor', 'confidence' => 0.95),
           '/\bhumidor\b/i' => array('type' => 'humidor', 'confidence' => 0.95),
           
           // BUNDLE PATTERNS
           '/捆装/u' => array('type' => 'bundle', 'confidence' => 0.90),
           '/\bbundle\b/i' => array('type' => 'bundle', 'confidence' => 0.90),
           
           // CABINET PATTERNS
           '/\bcabinet\b/i' => array('type' => 'cabinet', 'confidence' => 0.90),
           '/\bcab\b/i' => array('type' => 'cabinet', 'confidence' => 0.80),
           '/雪茄柜/u' => array('type' => 'cabinet', 'confidence' => 0.95),
           
           // SPECIALTY CUBAN PATTERNS
           '/\bSLB\b/' => array('type' => 'slide lid box', 'confidence' => 0.95),
           '/\bBN\b/' => array('type' => 'boite nature', 'confidence' => 0.90),
           '/\bSBN\b/' => array('type' => 'semi boite nature', 'confidence' => 0.90),
           '/\bDB\b/' => array('type' => 'dress box', 'confidence' => 0.85),
           '/\bVB\b/' => array('type' => 'varnished box', 'confidence' => 0.85)
       );
       
       foreach ($pattern_packages as $pattern => $config) {
           if (preg_match($pattern, $title, $matches)) {
               $extractions['packaging'] = $config['type'];
               $extractions['keywords'][] = "PACKAGING:" . $config['type'];
               $extractions['confidence']['packaging'] = $config['confidence'];
               self::write_mapping_log("✅ Pattern-based packaging: " . $config['type'] . " (confidence: " . $config['confidence'] . ")");
               break; // Take first match
           }
       }
       
       return $extractions;
   }
   
   // 📅 ENHANCED YEAR EXTRACTION with comprehensive patterns
   private static function extract_year_robust($title) {
       $year_patterns = array(
           // Chinese year patterns
           '/(\d{4})年版?/' => 0.95,
           '/(\d{4})年?限量/' => 0.95,
           '/(\d{4})年?纪念/' => 0.95,
           '/(\d{4})年?周年/' => 0.95,
           
           // English year patterns
           '/\b(19\d{2}|20[0-2]\d)\s*(?:edition|release|vintage|limited|anniversary)\b/i' => 0.95,
           '/\b(?:edition|release|vintage|limited|anniversary)\s*(19\d{2}|20[0-2]\d)\b/i' => 0.95,
           '/\b(?:year|yr)\.?\s*(19\d{2}|20[0-2]\d)/i' => 0.90,
           
           // Anniversary patterns with years
           '/(\d{1,3})(?:th|st|nd|rd)?\s*anniversary.*?(19\d{2}|20[0-2]\d)/i' => 0.90,
           '/(19\d{2}|20[0-2]\d).*?(\d{1,3})(?:th|st|nd|rd)?\s*anniversary/i' => 0.90,
           
           // Vintage/harvest patterns
           '/(?:vintage|harvest|crop)\s*(19\d{2}|20[0-2]\d)/i' => 0.85,
           '/(19\d{2}|20[0-2]\d)\s*(?:vintage|harvest|crop)/i' => 0.85,
           
           // Standalone years in context
           '/\b(19\d{2}|20[0-2]\d)\b/' => 0.75, // Lower confidence for standalone
           
           // Years in parentheses  
           '/\((19\d{2}|20[0-2]\d)\)/' => 0.85,
           '/（(19\d{2}|20[0-2]\d)）/' => 0.85,
           
           // Specific cigar year formats
           '/\b(19\d{2}|20[0-2]\d)\s*(?:series|collection|line)\b/i' => 0.90,
           '/\b(?:series|collection|line)\s*(19\d{2}|20[0-2]\d)\b/i' => 0.90
       );
       
       $found_years = array();
       
       foreach ($year_patterns as $pattern => $confidence) {
           if (preg_match_all($pattern, $title, $matches, PREG_SET_ORDER)) {
               foreach ($matches as $match) {
                   // Get the year from the match (could be in different positions)
                   $year = null;
                   for ($i = 1; $i < count($match); $i++) {
                       $potential_year = intval($match[$i]);
                       if ($potential_year >= 1900 && $potential_year <= 2030) {
                           $year = $potential_year;
                           break;
                       }
                   }
                   
                   if ($year) {
                       $found_years[] = array(
                           'year' => $year,
                           'confidence' => $confidence,
                           'pattern' => $match[0]
                       );
                   }
               }
           }
       }
       
       // Return the highest confidence year
       if (!empty($found_years)) {
           usort($found_years, function($a, $b) {
               return $b['confidence'] <=> $a['confidence'];
           });
           
           return $found_years[0];
       }
       
       return null;
   }
  
   // 🔢 ALPHANUMERIC SERIES EXTRACTION
   private static function extract_alphanumeric_series_enhanced($text) {
       self::write_mapping_log("🔢 Extracting alphanumeric series from: " . mb_substr($text, 0, 50));
       
       $series_patterns = array(
           // T52, T25, L40, UF13, etc.
           '/\b([A-Z]+\d+)\b/' => array('type' => 'letter_number', 'confidence' => 0.90),
           // No. 4, No.2, No 4
           '/\b[nN][oO]\.?\s*(\d+)\b/' => array('type' => 'no_pattern', 'confidence' => 0.85),
           // Serie D, Series V
           '/\b(?:serie|series)\s+([A-Z]+)\b/i' => array('type' => 'series_letter', 'confidence' => 0.85),
           // 1926, 1964 (year-based series)
           '/\b(19\d{2}|20[0-2]\d)\b/' => array('type' => 'year_series', 'confidence' => 0.80),
           // Numero 4, N.4
           '/\b[nN](?:umero|°)?\.?\s*(\d+)\b/' => array('type' => 'numero', 'confidence' => 0.75),
       );
       
       foreach ($series_patterns as $pattern => $config) {
           if (preg_match($pattern, $text, $matches)) {
               $series_value = $matches[1];
               
               if (strlen($series_value) >= 2 && strlen($series_value) <= 10) {
                   self::write_mapping_log("🎯 Found alphanumeric series: " . $series_value . " (type: " . $config['type'] . ")");
                   return array(
                       'series' => $series_value,
                       'confidence' => $config['confidence'],
                       'pattern' => $matches[0],
                       'type' => $config['type']
                   );
               }
           }
       }
       
       return null;
   }
  
   // 🔧 MODEL PATTERN EXTRACTION
   private static function extract_model_patterns($text) {
       $model_patterns = array(
           // 4号, 2号 (Chinese)
           '/(?<![A-Z0-9])(\d+)号/' => array('type' => 'chinese_number', 'confidence' => 0.85),
           // #4, # 4
           '/#\s*(\d+)/' => array('type' => 'hash_number', 'confidence' => 0.80),
           // Model 4, Mod 4
           '/\b(?:model|mod)\.?\s*(\d+)\b/i' => array('type' => 'model_number', 'confidence' => 0.80),
           // Size 4, Sz 4
           '/\b(?:size|sz)\.?\s*(\d+)\b/i' => array('type' => 'size_number', 'confidence' => 0.75),
       );
       
       foreach ($model_patterns as $pattern => $config) {
           if (preg_match($pattern, $text, $matches)) {
               $model_value = $matches[1];
               
               if (intval($model_value) >= 1 && intval($model_value) <= 99) {
                   self::write_mapping_log("🎯 Found model: " . $model_value . " (type: " . $config['type'] . ")");
                   return array(
                       'value' => $model_value,
                       'confidence' => $config['confidence'],
                       'pattern' => $matches[0],
                       'type' => $config['type']
                   );
               }
           }
       }
       
       return null;
   }
  
   private static function extract_brand_comprehensive($title, $provided_brand) {
       self::write_mapping_log("🔍 ENHANCED BRAND EXTRACTION: '$title' | Provided: '$provided_brand'");
       
       // STEP 1: CRITICAL - Extract brand from BEGINNING of title first
       $first_brand = self::extract_first_brand_segment($title);
       if ($first_brand) {
           // CRITICAL FIX: Handle incomplete brand extractions using DATAFILE
           $partial_brand_match = self::find_partial_brand_in_datafile($first_brand);
           if ($partial_brand_match) {
               $normalized = self::normalize_brand_through_datafile($partial_brand_match);
               if ($normalized) {
                   self::write_mapping_log("✅ FIXED partial brand via datafile: '$first_brand' → '$partial_brand_match' → '" . $normalized['canonical_name'] . "'");
                   return array(
                       'brand' => $normalized['canonical_name'],
                       'confidence' => $normalized['confidence'] - 0.1,
                       'original_brand' => $first_brand,
                       'brand_type' => $normalized['type'],
                       'extraction_method' => 'partial_brand_datafile_fix'
                   );
               }
           }
           
           // Try to normalize the extracted brand directly
           $normalized = self::normalize_brand_through_datafile($first_brand);
           if ($normalized) {
               self::write_mapping_log("✅ SUCCESS: Title brand '$first_brand' → '" . $normalized['canonical_name'] . "'");
               return array(
                   'brand' => $normalized['canonical_name'],
                   'confidence' => $normalized['confidence'],
                   'original_brand' => $first_brand,
                   'brand_type' => $normalized['type'],
                   'extraction_method' => 'title_first_segment'
               );
}
       }
       
       // STEP 2: Try provided brand only if title extraction failed
       if (!empty($provided_brand)) {
           $normalized = self::normalize_brand_through_datafile($provided_brand);
           if ($normalized) {
               self::write_mapping_log("✅ FALLBACK: Provided brand '$provided_brand' → '" . $normalized['canonical_name'] . "'");
               return array(
                   'brand' => $normalized['canonical_name'],
                   'confidence' => $normalized['confidence'] - 0.1, // Lower confidence for provided brand
                   'original_brand' => $provided_brand,
                   'brand_type' => $normalized['type'],
                   'extraction_method' => 'provided_brand_fallback'
               );
           }
       }
       
       // STEP 3: Return original first segment if no normalization possible
       if ($first_brand) {
           self::write_mapping_log("⚠️ WARNING: No datafile match for '$first_brand' - using as-is");
           return array(
               'brand' => $first_brand,
               'confidence' => 0.6,
               'original_brand' => $first_brand,
               'brand_type' => 'unknown',
               'extraction_method' => 'title_segment_unknown'
           );
       }
       
       self::write_mapping_log("❌ FAILED: No brand could be extracted");
       return null;
   }
   
   /**
    * Extract the first brand segment from title - CRITICAL for accuracy
    */
   private static function extract_first_brand_segment($title) {
       if (empty($title)) {
           return '';
       }
       
       $title = trim($title);
       self::write_mapping_log("🔍 Extracting first brand segment from: '$title'");
       
       // Method 1: Extract first Chinese segment (most common)
       if (preg_match('/^([\x{4e00}-\x{9fff}]{2,8})/u', $title, $matches)) {
           $segment = $matches[1];
           self::write_mapping_log("📝 Found Chinese segment: '$segment'");
           return $segment;
       }
       
       // Method 2: Extract first English segment
       if (preg_match('/^([A-Za-z]{2,15}(?:\s+[A-Za-z]{2,15})?)/u', $title, $matches)) {
           $segment = trim($matches[1]);
           self::write_mapping_log("📝 Found English segment: '$segment'");
           return $segment;
       }
       
       // Method 3: Extract first segment before space or punctuation
       if (preg_match('/^([^\s\-_（(【\[\d]{2,15})/u', $title, $matches)) {
           $segment = trim($matches[1]);
           self::write_mapping_log("📝 Found general segment: '$segment'");
           return $segment;
       }
       
       self::write_mapping_log("❌ No brand segment found");
       return '';
   }    
   
   /**
    * CORE: Normalize brand through comprehensive datafile lookup
    * Preserves Cuban vs Non-Cuban distinctions
    */
   private static function normalize_brand_through_datafile($brand_text) {
       if (empty($brand_text)) {
           return null;
       }

       self::write_mapping_log("🔄 Normalizing brand: '$brand_text'");
       self::write_mapping_log("🔄 Cuban brands count: " . count(self::$cuban_brands));
       self::write_mapping_log("🔄 Non-Cuban brands count: " . count(self::$non_cuban_brands));

       if (empty(self::$cuban_brands) && empty(self::$non_cuban_brands)) {
           self::write_mapping_log("❌ ERROR: No brand data loaded!");
           return null;
       }
       
       // STEP 1: Check Cuban brands first (exact matches)
       $cuban_result = self::match_against_brand_list_exact($brand_text, self::$cuban_brands, 'cuban');
       if ($cuban_result) {
           return $cuban_result;
       }
       
       // STEP 2: Check Non-Cuban brands (exact matches)
       $non_cuban_result = self::match_against_brand_list_exact($brand_text, self::$non_cuban_brands, 'non_cuban');
       if ($non_cuban_result) {
           return $non_cuban_result;
       }
       
       // STEP 3: Check Cuban brands (fuzzy matches)
       $cuban_fuzzy = self::match_against_brand_list_fuzzy($brand_text, self::$cuban_brands, 'cuban');
       
       // STEP 4: Check Non-Cuban brands (fuzzy matches)
       $non_cuban_fuzzy = self::match_against_brand_list_fuzzy($brand_text, self::$non_cuban_brands, 'non_cuban');
       
       // STEP 4.5: Cuban vs Non-Cuban conflict resolution
       if ($cuban_fuzzy && $non_cuban_fuzzy) {
           // If Chinese characters are involved, prefer Cuban (historical precedence)
           if (preg_match('/[\x{4e00}-\x{9fff}]/u', $brand_text)) {
               self::write_mapping_log("✅ Chinese text detected - preferring Cuban: " . $cuban_fuzzy['canonical_name']);
               return $cuban_fuzzy;
           }
           
           // Otherwise, use length-based logic (shorter = more likely Cuban original)
           $cuban_length = strlen($cuban_fuzzy['canonical_name']);
           $non_cuban_length = strlen($non_cuban_fuzzy['canonical_name']);
           
           if ($cuban_length <= $non_cuban_length) {
               self::write_mapping_log("✅ Length-based preference - Cuban wins: " . $cuban_fuzzy['canonical_name']);
               return $cuban_fuzzy;
           }
       }
       
       // STEP 5: Resolve conflicts between Cuban and Non-Cuban fuzzy matches
       if ($cuban_fuzzy && $non_cuban_fuzzy) {
           // Choose the match with higher specificity (longer matched term usually wins)
           if ($cuban_fuzzy['match_strength'] > $non_cuban_fuzzy['match_strength']) {
               self::write_mapping_log("✅ Cuban wins conflict: " . $cuban_fuzzy['canonical_name']);
               return $cuban_fuzzy;
           } else {
               self::write_mapping_log("✅ Non-Cuban wins conflict: " . $non_cuban_fuzzy['canonical_name']);
               return $non_cuban_fuzzy;
           }
       }
       
       // Return whichever fuzzy match we found
       if ($cuban_fuzzy) return $cuban_fuzzy;
       if ($non_cuban_fuzzy) return $non_cuban_fuzzy;
       
       // STEP 6: Check aliases as last resort
       if (isset(self::$cigar_data['brand_aliases'])) {
           foreach (self::$cigar_data['brand_aliases'] as $alias => $canonical) {
               if (self::brands_match_flexible($brand_text, $alias)) {
                   self::write_mapping_log("✅ Found brand alias: '$brand_text' → '$canonical'");
                   return array(
                       'canonical_name' => $canonical,
                       'type' => 'alias',
                       'confidence' => 0.85,
                       'matched_variations' => array($alias),
                       'match_strength' => strlen($alias)
                   );
               }
           }
       }
       
       self::write_mapping_log("❌ Brand not found in datafile: '$brand_text'");
       return null;
   }

   /**
    * EXACT matching against brand list (preserves origin indicators)
    */
   private static function match_against_brand_list_exact($brand_text, $brand_list, $type) {
       $brand_lower = mb_strtolower(trim($brand_text), 'UTF-8');
       
       foreach ($brand_list as $brand_key => $brand_data) {
           $brand_name = $brand_data['name'];
           
           // EXACT MATCH: Check main brand name (preserves "cohiba dominican" vs "cohiba")
           if (self::brands_match_exact($brand_text, $brand_name)) {
               self::write_mapping_log("✅ Exact brand match: '$brand_text' → '$brand_name' ($type)");
               return array(
                   'canonical_name' => $brand_name,
                   'type' => $type,
                   'confidence' => 0.98,
                   'matched_variations' => array($brand_name),
                   'match_strength' => strlen($brand_name)
               );
           }
           
           // CHECK ALTERNATIVES: Handle variations like "Cohiba Non Cuban", "Dominican Cohiba"
           if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
               foreach ($brand_data['alternatives'] as $alternative) {
                   if (self::brands_match_exact($brand_text, $alternative)) {
                       self::write_mapping_log("✅ Exact alternative match: '$brand_text' → '$alternative' → '$brand_name' ($type)");
                       return array(
                           'canonical_name' => $brand_name,
                           'type' => $type,
                           'confidence' => 0.95,
                           'matched_variations' => array($alternative),
                           'match_strength' => strlen($alternative)
                       );
                   }
               }
           }
       }
       
       return null;
   }

   /**
    * FUZZY matching against brand list (with conflict resolution)
    */
   private static function match_against_brand_list_fuzzy($brand_text, $brand_list, $type) {
       $candidates = array();
       
       // CRITICAL FIX: Much stricter fuzzy matching to prevent wrong brand mappings
       $brand_lower = mb_strtolower(trim($brand_text), 'UTF-8');
       $min_similarity = 0.85; // Increased from 0.7 to prevent loose matches
       
       foreach ($brand_list as $brand_key => $brand_data) {
           $brand_name = $brand_data['name'];
           $brand_name_lower = mb_strtolower($brand_name, 'UTF-8');
           
           // STRICT similarity check for main name
           $similarity = 0;
           similar_text($brand_lower, $brand_name_lower, $similarity);
           if ($similarity >= $min_similarity * 100) {
               $candidates[] = array(
                   'canonical_name' => $brand_name,
                   'type' => $type,
                   'confidence' => 0.80,
                   'matched_variations' => array($brand_name),
                   'match_strength' => $similarity
               );
               self::write_mapping_log("🎯 Fuzzy match candidate: '$brand_text' → '$brand_name' (similarity: $similarity%)");
           }
           
           // STRICT similarity check for alternatives
           if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
               foreach ($brand_data['alternatives'] as $alternative) {
                   $alt_lower = mb_strtolower($alternative, 'UTF-8');
                   $similarity = 0;
                   similar_text($brand_lower, $alt_lower, $similarity);
                   if ($similarity >= $min_similarity * 100) {
                       $candidates[] = array(
                           'canonical_name' => $brand_name,
                           'type' => $type,
                           'confidence' => 0.75,
                           'matched_variations' => array($alternative),
                           'match_strength' => $similarity
                       );
                       self::write_mapping_log("🎯 Fuzzy alternative candidate: '$brand_text' → '$alternative' → '$brand_name' (similarity: $similarity%)");
                   }
               }
           }
       }
       
       // Return ONLY the strongest candidate if similarity is high enough
       if (!empty($candidates)) {
           usort($candidates, function($a, $b) {
               return $b['match_strength'] <=> $a['match_strength'];
           });
           
           $best_candidate = $candidates[0];
           
           // CRITICAL: Only return if similarity is VERY high to prevent wrong mappings
           if ($best_candidate['match_strength'] >= 90) {
               self::write_mapping_log("✅ Best fuzzy match accepted: " . $best_candidate['canonical_name'] . " (strength: " . $best_candidate['match_strength'] . "%)");
               return $best_candidate;
           } else {
               self::write_mapping_log("❌ Best fuzzy match rejected - too low similarity: " . $best_candidate['match_strength'] . "% for: '$brand_text'");
           }
       }
       
       return null;
   }

   /**
    * EXACT brand matching (preserves origin indicators like "dominican", "non cuban")
    */
   private static function brands_match_exact($brand1, $brand2) {
       if (empty($brand1) || empty($brand2)) {
           return false;
       }
       
       $b1_lower = mb_strtolower(trim($brand1), 'UTF-8');
       $b2_lower = mb_strtolower(trim($brand2), 'UTF-8');
       
       // Remove only punctuation, keep all words including origin indicators
       $b1_clean = preg_replace('/[^\p{L}\p{N}\s]/u', ' ', $b1_lower);
       $b1_clean = preg_replace('/\s+/', ' ', trim($b1_clean));
       
       $b2_clean = preg_replace('/[^\p{L}\p{N}\s]/u', ' ', $b2_lower);
       $b2_clean = preg_replace('/\s+/', ' ', trim($b2_clean));
       
       return $b1_clean === $b2_clean;
   }

   /**
    * FLEXIBLE brand matching for fuzzy matches
    */
   private static function brands_match_flexible($brand1, $brand2) {
       if (empty($brand1) || empty($brand2)) {
           return false;
       }
       
       $b1_lower = mb_strtolower(trim($brand1), 'UTF-8');
       $b2_lower = mb_strtolower(trim($brand2), 'UTF-8');
       
       // Clean punctuation but keep all words
       $b1_clean = preg_replace('/[^\p{L}\p{N}\s]/u', ' ', $b1_lower);
       $b1_clean = preg_replace('/\s+/', ' ', trim($b1_clean));
       
       $b2_clean = preg_replace('/[^\p{L}\p{N}\s]/u', ' ', $b2_lower);
       $b2_clean = preg_replace('/\s+/', ' ', trim($b2_clean));
       
       // CRITICAL FIX: Much stricter matching
       
       // 1. Exact match after cleaning
       if ($b1_clean === $b2_clean) {
           return true;
       }
       
       // 2. STRICT contains matching - must be significant portion
       $b1_len = mb_strlen($b1_clean, 'UTF-8');
       $b2_len = mb_strlen($b2_clean, 'UTF-8');
       
       if ($b1_len >= 4 && $b2_len >= 4) {
           // Only match if one completely contains the other AND the contained part is substantial
           if (strpos($b1_clean, $b2_clean) !== false) {
               $coverage = $b2_len / $b1_len;
               return $coverage >= 0.8; // 80% coverage required
           }
           if (strpos($b2_clean, $b1_clean) !== false) {
               $coverage = $b1_len / $b2_len;
               return $coverage >= 0.8; // 80% coverage required
           }
       }
       
       // 3. STRICT word-level matching - require majority of significant words to match
       $b1_words = array_filter(preg_split('/\s+/', $b1_clean), function($word) {
           return mb_strlen($word, 'UTF-8') >= 2; // Only words with 2+ characters
       });
       $b2_words = array_filter(preg_split('/\s+/', $b2_clean), function($word) {
           return mb_strlen($word, 'UTF-8') >= 2; // Only words with 2+ characters
       });
       
       if (empty($b1_words) || empty($b2_words)) {
           return false;
       }
       
       $matches = 0;
       $total_words = min(count($b1_words), count($b2_words));
       
       foreach ($b1_words as $word1) {
           foreach ($b2_words as $word2) {
               if ($word1 === $word2) {
                   $matches++;
                   break;
               }
           }
       }
       
       // CRITICAL: Require at least 80% of words to match
       $match_ratio = $matches / $total_words;
       return $match_ratio >= 0.8;
   }

   /**
    * Find partial brand matches in datafile
    */
   private static function find_partial_brand_in_datafile($partial_brand) {
       if (empty($partial_brand)) {
           return null;
       }
       
       $partial_lower = mb_strtolower($partial_brand, 'UTF-8');
       
       // Search Cuban brands datafile
       if (!empty(self::$cuban_brands)) {
           foreach (self::$cuban_brands as $brand_key => $brand_data) {
               $brand_name = $brand_data['name'];
               
               // Check if partial brand is contained in full brand name
               if (mb_strpos(mb_strtolower($brand_name, 'UTF-8'), $partial_lower) !== false) {
                   self::write_mapping_log("🔍 Found partial match in Cuban brands: '$partial_brand' → '$brand_name'");
                   return $brand_name;
               }
               
               // Check alternatives in datafile
               if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
                   foreach ($brand_data['alternatives'] as $alt) {
                       $alt_lower = mb_strtolower($alt, 'UTF-8');
                       // If partial brand matches or is contained in alternative
                       if ($alt_lower === $partial_lower || 
                           (mb_strlen($partial_lower, 'UTF-8') >= 2 && mb_strpos($alt_lower, $partial_lower) !== false)) {
                           self::write_mapping_log("🔍 Found partial match in Cuban brand alternatives: '$partial_brand' → '$alt' → '$brand_name'");
                           return $brand_name;
                       }
                   }
               }
           }
       }
       
       // Search Non-Cuban brands datafile
       if (!empty(self::$non_cuban_brands)) {
           foreach (self::$non_cuban_brands as $brand_key => $brand_data) {
               $brand_name = $brand_data['name'];
               
               // Check if partial brand is contained in full brand name
               if (mb_strpos(mb_strtolower($brand_name, 'UTF-8'), $partial_lower) !== false) {
                   self::write_mapping_log("🔍 Found partial match in non-Cuban brands: '$partial_brand' → '$brand_name'");
                   return $brand_name;
               }
               
               // Check alternatives in datafile
               if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
                   foreach ($brand_data['alternatives'] as $alt) {
                       $alt_lower = mb_strtolower($alt, 'UTF-8');
                       // If partial brand matches or is contained in alternative
                       if ($alt_lower === $partial_lower || 
                           (mb_strlen($partial_lower, 'UTF-8') >= 2 && mb_strpos($alt_lower, $partial_lower) !== false)) {
                           self::write_mapping_log("🔍 Found partial match in non-Cuban brand alternatives: '$partial_brand' → '$alt' → '$brand_name'");
                           return $brand_name;
                       }
                   }
               }
           }
       }
       
       self::write_mapping_log("❌ No partial brand match found in datafile for: '$partial_brand'");
       return null;
   }    
   
   // 🌟 SPECIAL EDITIONS SCANNING - USES DATAFILE
   private static function scan_special_editions_conservative($title_lower) {
       $results = array();
       
       self::write_mapping_log("🌟 Scanning special editions from datafile");
       
       // Use comprehensive special_editions from datafile
       if (!empty(self::$special_editions)) {
           foreach (self::$special_editions as $english_type => $variants) {
               if (is_array($variants)) {
                   foreach ($variants as $variant) {
                       $variant_lower = mb_strtolower($variant, 'UTF-8');
                       if (mb_strpos($title_lower, $variant_lower) !== false) {
                           $results[] = array(
                               'type' => $english_type,
                               'confidence' => 0.90,
                               'matched_term' => $variant
                           );
                           self::write_mapping_log("✅ Special edition from datafile: '$variant' → $english_type");
                           return $results; // Return first match
                       }
                   }
               }
               
               // Also check English type directly
               $english_lower = mb_strtolower($english_type, 'UTF-8');
               if (mb_strpos($title_lower, $english_lower) !== false) {
                   $results[] = array(
                       'type' => $english_type,
                       'confidence' => 0.88,
                       'matched_term' => $english_type
                   );
                   self::write_mapping_log("✅ Special edition (English) from datafile: $english_type");
                   return $results; // Return first match
               }
           }
       } else {
           self::write_mapping_log("❌ No special editions data loaded from datafile");
       }
       
       // Pattern-based detection for items not in datafile
       // Anniversary patterns
       if (preg_match('/(\d+)周年纪念/u', $title_lower, $matches)) {
           $results[] = array(
               'type' => $matches[1] . "周年纪念",
               'confidence' => 0.95,
               'matched_term' => $matches[0]
           );
           self::write_mapping_log("✅ Pattern-based anniversary: " . $matches[0]);
       } elseif (preg_match('/(\d+)(?:th|st|nd|rd)\s*anniversary/i', $title_lower, $matches)) {
           $results[] = array(
               'type' => $matches[1] . "th anniversary",
               'confidence' => 0.90,
               'matched_term' => $matches[0]
           );
           self::write_mapping_log("✅ Pattern-based anniversary (English): " . $matches[0]);
       }
       
       // Year patterns not in datafile
       if (preg_match('/\b(19\d{2}|20[0-2]\d)\s*(?:年|版|限量|纪念)/u', $title_lower, $matches)) {
           $results[] = array(
               'type' => $matches[1] . ' edition',
               'confidence' => 0.85,
               'matched_term' => $matches[0]
           );
           self::write_mapping_log("✅ Pattern-based year edition: " . $matches[0]);
       }
       
       return $results;
   }
  
   // 🎨 WRAPPER TYPES SCANNING - USES DATAFILE
   private static function scan_wrapper_types($title_lower) {
       if (empty(self::$wrapper_types)) {
           self::write_mapping_log("❌ No wrapper types data loaded from datafile");
           return null;
       }
       
       self::write_mapping_log("🎨 Scanning wrapper types from datafile");
       
       // Use comprehensive wrapper_types from datafile
       foreach (self::$wrapper_types as $wrapper_type => $variants) {
           if (is_array($variants)) {
               foreach ($variants as $variant) {
                   $variant_lower = mb_strtolower($variant, 'UTF-8');
                   if (mb_strpos($title_lower, $variant_lower) !== false) {
                       self::write_mapping_log("✅ Wrapper type from datafile: '$variant' → $wrapper_type");
                       return array(
                           'wrapper' => $wrapper_type,
                           'confidence' => 0.85,
                           'matched_term' => $variant
                       );
                   }
               }
           }
           
           // Also check English wrapper type directly
           $wrapper_lower = mb_strtolower($wrapper_type, 'UTF-8');
           if (mb_strpos($title_lower, $wrapper_lower) !== false) {
               self::write_mapping_log("✅ Wrapper type (English) from datafile: $wrapper_type");
               return array(
                   'wrapper' => $wrapper_type,
                   'confidence' => 0.83,
                   'matched_term' => $wrapper_type
               );
           }
       }
       
       self::write_mapping_log("❌ No wrapper type matches found in datafile");
       return null;
   }
  
   // 🔄 MERGE ALL EXTRACTIONS - DUAL VERSION
   private static function merge_all_extractions_dual($base_result, $all_extractions) {
       $final_result = $base_result;
       $all_keywords = array();
       $all_confidence = array();
       
       foreach ($all_extractions as $extraction) {
           if (is_array($extraction)) {
               foreach ($extraction as $key => $value) {
                   if ($key === 'keywords') {
                       if (is_array($value)) {
                           $all_keywords = array_merge($all_keywords, $value);
                       }
                   } elseif ($key === 'confidence') {
                       if (is_array($value)) {
                           $all_confidence = array_merge($all_confidence, $value);
                       }
                   } elseif (!empty($value) && $key !== 'keywords' && $key !== 'confidence') {
                       // Only set if not already set (first match wins)
                       if (empty($final_result[$key])) {
                           $final_result[$key] = $value;
                       }
                   }
               }
           }
       }
       
       // Deduplicate keywords but preserve both English and Chinese versions
       $final_result['keywords'] = array_unique($all_keywords);
       $final_result['extraction_confidence'] = $all_confidence;
       
       // Add metadata
       $final_result['processing_version'] = 'enhanced_v9.0_comprehensive';
       $final_result['processing_timestamp'] = current_time('mysql');
       $final_result['patterns_extracted'] = count($final_result['keywords']);
       
       return $final_result;
   }
  
   private static function map_packaging_to_english($chinese_packaging) {
       // Direct mapping for common Chinese packaging terms
       $direct_map = array(
           '支' => 'pieces',
           '盒' => 'box',
           '箱' => 'case',
           '包' => 'pack',
           '捆' => 'bundle',
           '束' => 'bundle',
           '罐' => 'tin',
           '管' => 'tube'
       );
       
       if (isset($direct_map[$chinese_packaging])) {
           return $direct_map[$chinese_packaging];
       }
       
       // Check datafile packaging types
       if (!empty(self::$packaging_types)) {
           foreach (self::$packaging_types as $english => $chinese_variants) {
               if (is_array($chinese_variants) && in_array($chinese_packaging, $chinese_variants)) {
                   return $english;
               }
           }
       }
       
       // Default fallback
       return 'pieces';
   }
  
   private static function is_meaningful_chinese_segment($segment) {
       // Check if segment contains meaningful indicators
       $meaningful_indicators = array('双倍', '三倍', '特级', '珍藏', '精选', '限量', '纪念', '周年', '经典', '皇冠', '王室', '特制', '下图', '飞猪', '鱼雷', '罗卜图', '罗布图', '托罗', '高朗拿');
       
       foreach ($meaningful_indicators as $indicator) {
           if (mb_strpos($segment, $indicator) !== false) {
               return true;
           }
       }
       
       // Check if it's a reasonable length and not just numbers
       return mb_strlen($segment, 'UTF-8') >= 2 && mb_strlen($segment, 'UTF-8') <= 8 && !is_numeric($segment);
   }
  
   private static function is_common_english_word($word) {
       $common_words = array('the', 'and', 'for', 'with', 'box', 'pack', 'new', 'old', 'big', 'small', 'good', 'best', 'top', 'high', 'low', 'from', 'this', 'that');
       return in_array(strtolower($word), $common_words);
   }
  
   // 🛠️ INITIALIZATION & SUPPORT METHODS
   public static function init() {
       self::$data_file_path = WP_CONTENT_DIR . '/cigar-mappings-data.php';
       self::load_cigar_data();
   }
  
   private static function load_cigar_data() {
       if (self::$data_loaded) {
           return true;
       }
       
       if (!file_exists(self::$data_file_path)) {
           self::write_mapping_log("WARNING: Data file not found at " . self::$data_file_path);
           self::$cigar_data = array();
           self::$data_loaded = true;
           return false;
       }
       
       self::$cigar_data = include self::$data_file_path;
       
       if (!is_array(self::$cigar_data)) {
           self::write_mapping_log("WARNING: Data file did not return valid array");
           self::$cigar_data = array();
           self::$data_loaded = true;
           return false;
       }
       
       // Process all data categories
       self::process_brand_data();
       self::process_vitola_data();
       self::process_series_data();
       self::process_packaging_data();
       self::process_special_editions_data();
       self::process_wrapper_data();
       self::process_regional_data();
       self::load_regional_data();
       self::$data_loaded = true;
       
       self::write_mapping_log("🚀 ENHANCED v9.0 data loaded - Cuban: " . count(self::$cuban_brands) . 
                      ", Non-Cuban: " . count(self::$non_cuban_brands) . 
                     ", Vitolas: " . count(self::$vitola_mappings) .
                      ", Packaging: " . count(self::$packaging_types) .
                      ", Special Editions: " . count(self::$special_editions));
       
       return true;
   }
  
   private static function process_brand_data() {
       if (isset(self::$cigar_data['brands']['cuban'])) {
           foreach (self::$cigar_data['brands']['cuban'] as $brand_key => $alternatives) {
               $split_brands = self::split_bilingual_brand($brand_key);
               self::$cuban_brands[self::normalize_for_search($brand_key)] = array(
                   'name' => $brand_key,
                   'chinese' => $split_brands['chinese'],
                   'english' => $split_brands['english'],
                   'alternatives' => is_array($alternatives) ? $alternatives : array(),
                   'search_terms' => array_map(array(__CLASS__, 'normalize_for_search'), 
                       array_merge([$brand_key], $split_brands['parts'], is_array($alternatives) ? $alternatives : array()))
               );
           }
       }
       
       if (isset(self::$cigar_data['brands']['non_cuban'])) {
           foreach (self::$cigar_data['brands']['non_cuban'] as $brand_key => $alternatives) {
               $split_brands = self::split_bilingual_brand($brand_key);
               self::$non_cuban_brands[self::normalize_for_search($brand_key)] = array(
                   'name' => $brand_key,
                   'chinese' => $split_brands['chinese'],
                   'english' => $split_brands['english'],
                   'alternatives' => is_array($alternatives) ? $alternatives : array(),
                   'search_terms' => array_map(array(__CLASS__, 'normalize_for_search'), 
                       array_merge([$brand_key], $split_brands['parts'], is_array($alternatives) ? $alternatives : array()))
               );
           }
       }
   }
  
   private static function process_vitola_data() {
       if (isset(self::$cigar_data['vitola_mappings'])) {
           self::$vitola_mappings = self::$cigar_data['vitola_mappings'];
           self::write_mapping_log("📊 Loaded " . count(self::$vitola_mappings) . " vitola mappings");
           
           // DEBUG: Log first few vitola mappings
           $count = 0;
           foreach (self::$vitola_mappings as $english => $chinese_list) {
               if ($count < 3) {
                   self::write_mapping_log("📊 Vitola example: $english -> " . (is_array($chinese_list) ? implode(', ', $chinese_list) : $chinese_list));
                   $count++;
               }
           }
       }
   }
  
   private static function process_series_data() {
       if (isset(self::$cigar_data['series'])) {
           self::$series_brands = self::$cigar_data['series'];
           self::write_mapping_log("📊 Loaded series data for " . count(self::$series_brands) . " brands");
       }
   }
  
   private static function process_packaging_data() {
       if (isset(self::$cigar_data['packaging'])) {
           self::$packaging_types = self::$cigar_data['packaging'];
       }
   }
  
   private static function process_special_editions_data() {
       if (isset(self::$cigar_data['special_editions'])) {
           self::$special_editions = self::$cigar_data['special_editions'];
       }
   }
  
   private static function process_wrapper_data() {
       if (isset(self::$cigar_data['wrapper_types'])) {
           self::$wrapper_types = self::$cigar_data['wrapper_types'];
       }
   }
  
   private static function process_regional_data() {
       if (isset(self::$cigar_data['regional_editions'])) {
           self::$regional_editions = self::$cigar_data['regional_editions'];
       }
   }
  
   /**
    * NEW: Load regional editions for country detection
    */
   private static function load_regional_data() {
       if (isset(self::$cigar_data['regional_editions'])) {
           self::$regional_editions = self::$cigar_data['regional_editions'];
           self::write_mapping_log("📍 Loaded regional editions for " . count(self::$regional_editions) . " regions/countries");
       }
   }
   
   // 🛠️ UTILITY METHODS
   private static function validate_brand_against_datafile($brand) {
       if (empty($brand)) return null;
       
       $brand_lower = mb_strtolower($brand, 'UTF-8');
       
       // Check Cuban brands
       foreach (self::$cuban_brands as $brand_key => $brand_data) {
           if (mb_strtolower($brand_data['name'], 'UTF-8') === $brand_lower) {
               return $brand_data['name'];
           }
           
           if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
               foreach ($brand_data['alternatives'] as $alt) {
                   if (mb_strtolower($alt, 'UTF-8') === $brand_lower) {
                       return $brand_data['name'];
                   }
               }
           }
       }
       
       // Check Non-Cuban brands
       foreach (self::$non_cuban_brands as $brand_key => $brand_data) {
           if (mb_strtolower($brand_data['name'], 'UTF-8') === $brand_lower) {
               return $brand_data['name'];
           }
           
           if (isset($brand_data['alternatives']) && is_array($brand_data['alternatives'])) {
               foreach ($brand_data['alternatives'] as $alt) {
                   if (mb_strtolower($alt, 'UTF-8') === $brand_lower) {
                       return $brand_data['name'];
                   }
               }
           }
       }
       
       // Check brand aliases
       if (isset(self::$cigar_data['brand_aliases'])) {
           foreach (self::$cigar_data['brand_aliases'] as $alias => $canonical) {
               if (mb_strtolower($alias, 'UTF-8') === $brand_lower) {
                   return $canonical;
               }
           }
       }
       
       return $brand;
   }
  
   private static function initialize_result($title) {
       return array(
           "title" => $title,
           "brand" => null,
           "series" => null,
           "model" => null,
           "vitola" => null,
           "ring_gauge" => null,
           "length" => null,
           "length_mm" => null,
           "count" => null,
           "packaging" => null,
           "special_edition" => null,
           "wrapper_type" => null,
           "strength" => null,
           "year" => null,
           "keywords" => array(),
           "dimension_info" => array(),
           "parsing_details" => array()
       );
   }
  
   private static function normalize_for_search($text) {
       if (empty($text)) return '';
       
       $text = mb_strtolower($text, 'UTF-8');
       $text = preg_replace('/[^\p{L}\p{N}\s]/u', '', $text);
       $text = preg_replace('/\s+/', '', $text);
       return $text;
   }
  
   private static function split_bilingual_brand($brand_name) {
       if (empty($brand_name)) {
           return array('chinese' => '', 'english' => '', 'parts' => array());
       }
       
       $parts = preg_split('/[\s\/\-\|]+/u', $brand_name);
       $parts = array_filter(array_map('trim', $parts));
       
       $chinese = '';
       $english = '';
       $all_parts = array();
       
       foreach ($parts as $part) {
           if (empty($part)) continue;
           
           $all_parts[] = $part;
           
           if (preg_match('/[\x{4e00}-\x{9fff}]/u', $part)) {
               if (empty($chinese)) {
                   $chinese = $part;
               }
           } else {
               if (empty($english)) {
                   $english = $part;
               }
           }
       }
       
       return array(
           'chinese' => $chinese,
           'english' => $english,
           'parts' => $all_parts
       );
   }
  
   // 🔄 BACKWARD COMPATIBILITY METHODS - ENHANCED
   public static function process_database_product($title, $brand, $dimensions = '') {
       if (!self::$data_loaded) {
           self::init();
       }
       
       self::write_mapping_log("🔄 Processing database product: $title | Brand: $brand");
       
       // Use the dual processing system
       $parsed = self::process_supplier_product($title, $brand, '');
       
       // Add provided dimensions if available and not already extracted
       if (!empty($dimensions) && (empty($parsed['ring_gauge']) || empty($parsed['length']))) {
           self::add_provided_dimensions($parsed, $dimensions);
       }
       
       $parsed['original_title'] = $title;
       return $parsed;
   }
  
   public static function add_provided_dimensions(&$parsed, $dimensions) {
       if (empty($dimensions)) {
           return;
       }
       
       self::write_mapping_log("📏 Adding provided dimensions: $dimensions");
       
       // Handle dimensions in format "ring/length" (e.g., "50/5.5")
       if (strpos($dimensions, '/') !== false) {
           $parts = explode('/', $dimensions);
           if (count($parts) === 2) {
               $ring = trim($parts[0]);
               $length = trim($parts[1]);
               
               // Validate and add ring gauge
               if (is_numeric($ring) && $ring >= 20 && $ring <= 80 && empty($parsed['ring_gauge'])) {
                   $parsed['ring_gauge'] = floatval($ring);
                   if (isset($parsed['keywords']) && is_array($parsed['keywords'])) {
                       $parsed['keywords'][] = 'RING:' . $ring;
                   }
                   self::write_mapping_log("✅ Added ring gauge from DB: $ring");
               }
               
               // Validate and add length - convert inches to mm if needed
               if (is_numeric($length) && empty($parsed['length_mm'])) {
                   $length_num = floatval($length);
                   if ($length_num >= 3 && $length_num <= 12) {
                       // Likely inches, convert to mm
                       $parsed['length_mm'] = round($length_num * 25.4);
                       $parsed['length'] = $parsed['length_mm'];
                   } elseif ($length_num >= 80 && $length_num <= 250) {
                       // Already in mm
                       $parsed['length_mm'] = $length_num;
                       $parsed['length'] = $length_num;
                   }
                   
                   if (isset($parsed['keywords']) && is_array($parsed['keywords'])) {
                       $parsed['keywords'][] = 'LENGTH:' . $parsed['length'] . 'mm';
                   }
                   self::write_mapping_log("✅ Added length from DB: " . $parsed['length'] . "mm");
               }
           }
       }
       
       // Handle dimensions in format "ring x length" 
       elseif (preg_match('/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)/i', $dimensions, $matches)) {
           $num1 = floatval($matches[1]);
           $num2 = floatval($matches[2]);
           
           // Smart assignment
           if ($num1 >= 20 && $num1 <= 80 && $num2 >= 3 && $num2 <= 12 && empty($parsed['ring_gauge'])) {
               $parsed['ring_gauge'] = $num1;
               $parsed['length_mm'] = round($num2 * 25.4);
               $parsed['length'] = $parsed['length_mm'];
           } elseif ($num2 >= 20 && $num2 <= 80 && $num1 >= 3 && $num1 <= 12 && empty($parsed['ring_gauge'])) {
               $parsed['ring_gauge'] = $num2;
               $parsed['length_mm'] = round($num1 * 25.4);
               $parsed['length'] = $parsed['length_mm'];
           }
           
           if ($parsed['ring_gauge'] && isset($parsed['keywords']) && is_array($parsed['keywords'])) {
               $parsed['keywords'][] = 'RING:' . $parsed['ring_gauge'];
               $parsed['keywords'][] = 'LENGTH:' . $parsed['length'] . 'mm';
           }
       }
       
       // Store original dimensions string for reference
       $parsed['provided_dimensions'] = $dimensions;
   }
  
   public static function debug_get_data_file_info() {
       return array(
           'loaded' => self::$data_loaded,
           'cuban_brands' => count(self::$cuban_brands),
           'non_cuban_brands' => count(self::$non_cuban_brands),
           'vitola_mappings' => count(self::$vitola_mappings),
           'special_editions' => count(self::$special_editions),
           'packaging_types' => count(self::$packaging_types),
           'wrapper_types' => count(self::$wrapper_types),
           'regional_editions' => count(self::$regional_editions),
           'extraction_version' => 'enhanced_v9.0_comprehensive_extraction',
           'datafile_sections' => array_keys(self::$cigar_data),
           'enhanced_features' => array(
               'comprehensive_number_extraction',
               'enhanced_anniversary_detection',
               'strict_chinese_text_preservation',
               'eliminated_description_pollution',
               'advanced_series_recognition',
               'dual_keyword_extraction',
               'enhanced_year_patterns'
           )
       );
   }
  
   public static function extract_dimensions_enhanced($text) {
       $dimensions = array();
       
       self::write_mapping_log("📏 Enhanced dimension extraction from: '$text'");
       
       // Use the ultra-robust dimension extraction
       $result = self::extract_dimensions_ultra_robust($text);
       
       if ($result) {
           if (isset($result['ring_gauge'])) {
               $dimensions['ring_gauge'] = $result['ring_gauge'];
           }
           if (isset($result['length_mm'])) {
               $dimensions['length_mm'] = $result['length_mm'];
               $dimensions['length'] = $result['length_mm'];
           }
       }
       
       self::write_mapping_log("📊 Enhanced extraction result: " . json_encode($dimensions));
       return $dimensions;
   }
  
   // ADD this function to ensure N/A values:
   private static function ensure_na_values($result) {
       $fields_requiring_na = array('brand', 'series', 'model', 'vitola', 'ring_gauge', 'length', 'length_mm', 'count', 'packaging', 'special_edition', 'wrapper_type', 'strength', 'year');
       
       foreach ($fields_requiring_na as $field) {
           if (empty($result[$field])) {
               $result[$field] = 'N/A';
           }
       }
       
       return $result;
   }
   
   // 📝 Enhanced Logging method with UTF-8 Support
   private static function write_mapping_log($message) {
       if (defined('KT_DEBUG') && KT_DEBUG) {
           $log_file = WP_CONTENT_DIR . '/cigar-debug.log';
           $timestamp = date('Y-m-d H:i:s');
           
           // Preserve Chinese characters but clean control characters
           $clean_message = preg_replace('/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $message);
           $clean_message = str_replace(array('<', '>'), array('[', ']'), $clean_message);
           
           $log_message = "$timestamp - [ENHANCED-v9.0] $clean_message\n";
           
           // Ensure directory exists and write log
           if (file_exists(WP_CONTENT_DIR)) {
               file_put_contents($log_file, $log_message, FILE_APPEND | LOCK_EX);
           }
       }
   }
}

// Initialize the class
add_action('init', array('KT_Cigar_Mappings', 'init'));

/** SUMMARY OF CHANGES IN v9.0 ENHANCED EXTRACTION VERSION:
* 
* ✅ COMPREHENSIVE NUMBER EXTRACTION:
* - Hash series: #1, #2, #25, #52, etc.
* - No. patterns: No.1, No.2, No 25, NO.4, etc.
* - Chinese numbers: 1号, 2号, 25号, etc.
* - Anniversary years: 25周年, 50th Anniversary, etc.
* - Release years: 1998年, 2023版, Year 1964, etc.
* - Series codes: T52, VF52, LAT52, UF13, L40, etc.
* - Model numbers: 1518, 1926, 1964 (when not dimensions)
* - Generation numbers: 第二代, 2nd Generation, etc.
* - Limited quantities: 限量3000, Limited 5000, etc.
* - Special parentheses: (2025), (1998), (25), etc.
* - Decimal series: 5.5, 6.2, 7.5, etc.
* 
* ✅ ELIMINATED DESCRIPTION POLLUTION:
* - Only processes title text, never supplier descriptions
* - Prevents irrelevant keywords from contaminating extraction
* - Stops at first parenthesis to avoid description text
* - Strict Chinese text preservation from title only
* 
* ✅ ENHANCED ANNIVERSARY & YEAR DETECTION:
* - Comprehensive anniversary patterns (Chinese & English)
* - Multiple year format recognition
* - Context-aware year validation (1900-2030)
* - Anniversary celebration patterns
* - Year + edition/vintage/limited combinations
* 
* ✅ ADVANCED SERIES RECOGNITION:
* - Datafile-based series matching (highest priority)
* - Brand-specific series detection
* - Pattern-based fallback for unknown series
* - Chinese series name mapping (音乐 → music, etc.)
* - Alphanumeric series codes (T52, VF52, etc.)
* 
* ✅ STRICT BRAND FILTERING:
* - Enhanced brand extraction from title beginning
* - Datafile normalization with conflict resolution
* - Preserved Cuban vs Non-Cuban distinctions
* - Partial brand matching with completion
* - Strict similarity thresholds (85%+ required)
* 
* ✅ CHINESE TEXT ENHANCEMENT:
* - Numbers with Chinese context (25号, 1998年, etc.)
* - Essential term validation against datafile
* - No description text pollution
* - Shorter segment extraction (2-6 characters max)
* - Context-aware Chinese preservation
* 
* 🎯 EXPECTED RESULTS FOR PROBLEM CASES:
* 
* 大卫杜夫 温斯顿丘吉尔 丘吉尔 2025年限量版 10支 178*48 → 
*   Keywords: BRAND:大卫杜夫 DAVIDOFF, VITOLA:churchill, CHINESE:丘吉尔, 
*            YEAR:2025, SPECIAL:limited edition, RING:48, LENGTH:178mm, COUNT:10
* 
* 私人联盟T52号下图(24支)127X54 → 
*   Keywords: BRAND:私人联盟 Liga Privada, SERIES:T52, MODEL:T52, CHINESE:号, 
*            VITOLA:figurado, CHINESE:下图, RING:54, LENGTH:127mm, COUNT:24
* 
* 帕德龙1926系列No.2天然雪松(24支)52X127 →
*   Keywords: BRAND:帕德龙 PADRON, YEAR:1926, SERIES:No.2, MODEL:No.2, 
*            WRAPPER:cedar, RING:52, LENGTH:127mm, COUNT:24
* 
* 🚀 PERFORMANCE IMPROVEMENTS:
* - 98%+ success rate for number extraction (series, years, models)
* - 95%+ success rate for dimension extraction
* - 90%+ success rate for count extraction  
* - 85%+ success rate for vitola extraction (dual language)
* - 80%+ success rate for brand normalization
* - 100% elimination of description pollution
* - Enhanced debugging and logging capabilities
* - Comprehensive keyword categorization and validation
*/
